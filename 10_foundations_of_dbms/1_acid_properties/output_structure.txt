â””â”€â”€ ./
    â””â”€â”€ 1_acid_theory.md
    â””â”€â”€ 1_atomicity/
        â””â”€â”€ 2_demo.sql
        â””â”€â”€ 1_theory.md
        â””â”€â”€ AppExample/
            â””â”€â”€ README.md
            â””â”€â”€ docker-compose.yml
            â””â”€â”€ init-db/
                â””â”€â”€ init.sql
            â””â”€â”€ server/
                â””â”€â”€ package.json
                â””â”€â”€ .env
                â””â”€â”€ app.js
                â””â”€â”€ prisma/
                    â””â”€â”€ schema.prisma
                â””â”€â”€ routes/
                    â””â”€â”€ accounts.js

Contents of 1_acid_theory.md:

# ðŸ”’ ACID Properties in Depth

In database systems, **ACID** is the gold standard for transaction reliability. Each letter represents a property that a DBMS must support to ensure data remains **consistent, safe, and usable** even under failure or high concurrency.

---

## ðŸ§© Breakdown of ACID

| Property        | Description                                           | Example Scenario                                              |
| --------------- | ----------------------------------------------------- | ------------------------------------------------------------- |
| **Atomicity**   | A transaction must be all-or-nothing.                 | Money transfer either debits AND credits, or neither happens. |
| **Consistency** | The DB must remain in a valid state before and after. | Schema rules, constraints, and relationships must hold.       |
| **Isolation**   | Concurrent transactions appear isolated.              | Alice edits profile while Bob changes password. No conflicts. |
| **Durability**  | Once committed, changes persist despite crashes.      | After power loss, you still see your last payment was saved.  |

---

## âœ… Why It Matters

Without ACID, you might face:

- Partial writes
- Dirty reads
- Corrupted data after a system crash
- Lost transactions in high concurrency apps

---

## ðŸ’¡ Real DBMS Support

| DBMS           | Atomicity | Consistency | Isolation     | Durability    |
| -------------- | --------- | ----------- | ------------- | ------------- |
| PostgreSQL     | âœ…        | âœ…          | âœ… MVCC       | âœ… WAL        |
| MySQL (InnoDB) | âœ…        | âœ…          | âœ… Locks      | âœ… WAL        |
| SQLite         | âœ…        | âœ…          | âœ… Serialized | âœ… Journaling |

> Even lightweight DBMSs like SQLite implement ACID using **journals** and **locking mechanisms**.

---

## ðŸ§ª Coming Up

In the next file `2_acid_sql_demo.sql`, youâ€™ll test these properties in SQL using:

- BEGIN / COMMIT / ROLLBACK
- Violating constraints
- Simulating crash scenarios

âž¡ï¸ After that, weâ€™ll break down what each query is doing in `2_acid_sql_demo_explained.md`.


Contents of 1_atomicity/2_demo.sql:

-- ðŸ§ª SQL Atomicity Demo

-- âœ… Success Case: Money transfer from Alice to Bob
BEGIN;

UPDATE account SET balance = balance - 100 WHERE name = 'Alice';
UPDATE account SET balance = balance + 100 WHERE name = 'Bob';

COMMIT;

-- âŒ Failure Case: Simulate error to trigger rollback
BEGIN;

UPDATE account SET balance = balance - 100 WHERE name = 'Alice';
UPDATE account SET balance = balance + (100 / 0) WHERE name = 'Bob'; -- force error

ROLLBACK;


Contents of 1_atomicity/1_theory.md:

# ðŸ’¥ Atomicity â€” All or Nothing

**Atomicity** is the principle that a transaction must either complete in full or have no effect at all. There is no "partial success" in a reliable database system.

---

## ðŸ“Œ Real-World Analogy

Imagine withdrawing money from an ATM:

- You insert your card
- You request $100
- The system debits your account
- Then gives you cash

If the system debits your account **but crashes before giving the cash**, atomicity ensures that the **debit is undone** â€” either all steps succeed, or none.

---

## ðŸ’¡ Formal Definition

> A transaction is **atomic** if it is indivisible:  
> either all its operations are executed, or none are.

Atomicity is enforced using:

- **Rollback logs**
- **Undo buffers**
- **Transaction boundaries** (`BEGIN`, `ROLLBACK`, `COMMIT`)

---

## ðŸš« Without Atomicity

| Scenario                          | What Happens                     |
| --------------------------------- | -------------------------------- |
| Insert succeeds, then crash       | Partial data, inconsistent state |
| Multi-table update fails midway   | One table updated, others not    |
| Constraint violation after update | Database left in invalid state   |

---

## ðŸ“„ Demo Summary

We simulate a money transfer between two users:

- Decrease `Alice`'s balance
- Increase `Bob`'s balance

To ensure **atomicity**, both updates are wrapped in a SQL `BEGIN ... COMMIT` transaction block. If something fails, we roll back the entire transaction.

---

## âœ… Success Scenario

```sql
BEGIN;

UPDATE account SET balance = balance - 100 WHERE name = 'Alice';
UPDATE account SET balance = balance + 100 WHERE name = 'Bob';

COMMIT;
```

This transfers 100 from Alice to Bob.

---

## âŒ Failure Scenario

```sql
BEGIN;

UPDATE account SET balance = balance - 100 WHERE name = 'Alice';
UPDATE account SET balance = balance + (100 / 0) WHERE name = 'Bob'; -- force error

ROLLBACK;
```

In this case:

- The second line throws a division-by-zero error
- PostgreSQL aborts the transaction
- The `ROLLBACK` ensures **Aliceâ€™s balance is unchanged**

---

## ðŸ’¡ Why This Proves Atomicity

| Guarantee      | Explanation                                            |
| -------------- | ------------------------------------------------------ |
| All-or-Nothing | Either both balances are updated, or none are          |
| Safe Failure   | If any operation fails, all changes are rolled back    |
| Manual Control | Uses `BEGIN`, `ROLLBACK`, `COMMIT` to manage atomicity |


Contents of 1_atomicity/AppExample/README.md:

# ðŸ’¾ Atomicity Demo with PostgreSQL, Prisma, and Docker

This project demonstrates the **Atomicity** property of ACID in a real-world money transfer system. It uses:

- ðŸ˜ PostgreSQL (via Docker) for reliable storage
- âš™ï¸ Prisma ORM (with explicit table mapping)
- ðŸš€ Express.js (Node.js) as the API layer

The goal is to show that **a transfer operation either fully succeeds (both accounts updated) or fully fails (no change at all)** â€” exactly what atomicity means.

---

## ðŸ“š What Is Atomicity?

**Atomicity** ensures that **all operations in a transaction are treated as a single unit** â€” they either all succeed or none of them are applied.

In this case:

- If Alice sends Bob $100,
  - âœ… Aliceâ€™s balance must decrease by $100
  - âœ… Bobâ€™s balance must increase by $100
- If either operation fails (e.g., Bob doesnâ€™t exist),
  - âŒ **Neither account should be changed**

This is implemented using **Prismaâ€™s `$transaction()`**, which wraps multiple operations into a single all-or-nothing database transaction.

---

## ðŸ“ Project Structure

```txt
.
â”œâ”€â”€ docker-compose.yml          # Starts PostgreSQL and seeds DB using init.sql
â”œâ”€â”€ init-db/
â”‚   â””â”€â”€ init.sql                # SQL script that creates `account` table and seeds Alice & Bob
â””â”€â”€ server/
    â”œâ”€â”€ .env                    # DB connection string
    â”œâ”€â”€ app.js                  # Express.js server entry point
    â”œâ”€â”€ package.json            # Dependencies (Prisma, Express, etc.)
    â”œâ”€â”€ prisma/
    â”‚   â””â”€â”€ schema.prisma       # Prisma model mapped to lowercase SQL table
    â””â”€â”€ routes/
        â””â”€â”€ accounts.js         # API routes to get accounts and transfer money
```

---

## âš™ï¸ Setup Instructions

### 1. ðŸ³ Start the PostgreSQL Database

This creates the `bankdb` database and initializes the `account` table.

```bash
docker compose up -d
```

> It uses `init-db/init.sql` to define the table and seed Alice and Bob.

---

### 2. ðŸ“¦ Install Server Dependencies

```bash
cd server
npm install
```

---

### 3. ðŸ”§ Generate the Prisma Client

```bash
npx prisma generate
```

> Prisma reads `schema.prisma`, which maps the `Account` model to the actual lowercase table:

```prisma
model Account {
  ...
  @@map("account")
}
```

---

### 4. ðŸš€ Start the API Server

```bash
nodemon app.js
```

Visit: [http://localhost:3001/api/accounts](http://localhost:3001/api/accounts)

You should see:

```json
[
  { "id": 1, "name": "Alice", "balance": 1000 },
  { "id": 2, "name": "Bob", "balance": 500 }
]
```

---

## ðŸ” Transfer Route: Proving Atomicity

### Endpoint

```
POST /api/accounts/transfer
Content-Type: application/json
```

### Payload

```json
{
  "from": "Alice",
  "to": "Bob",
  "amount": 100
}
```

### Behavior

This executes:

```js
await prisma.$transaction([
  prisma.Account.update({
    where: { name: from },
    data: { balance: { decrement: amount } },
  }),
  prisma.Account.update({
    where: { name: to },
    data: { balance: { increment: amount } },
  }),
]);
```

- If **both succeed** â†’ COMMIT âœ…
- If **either fails** (e.g., Bob doesnâ€™t exist) â†’ ROLLBACK âŒ

---

### ðŸ”¬ Test Failure (Rollback)

```json
{
  "from": "Alice",
  "to": "Charlie",
  "amount": 100
}
```

- Charlie doesn't exist â†’ second update fails
- Aliceâ€™s balance **remains unchanged**
- Response:
  ```json
  {
    "success": false,
    "message": "No 'Charlie' found"
  }
  ```

---

## âœ… Why Atomicity Is Guaranteed

1. **Transaction Used**: Prismaâ€™s `$transaction()` wraps both balance updates in a true SQL transaction.
2. **Rollback-on-Failure**: If either update fails (e.g. due to a constraint, bad name), Prisma automatically rolls back the entire transaction.
3. **PostgreSQL Reliability**: PostgreSQL enforces transactional semantics and ACID guarantees.
4. **Balance Constraints**: The schema has a `CHECK (balance >= 0)` to prevent invalid writes.

---

## ðŸ§  Summary

| Feature               | Description                                      |
| --------------------- | ------------------------------------------------ |
| ðŸ”„ Transaction Safety | Ensures full transfer succeeds or fails entirely |
| ðŸ” ACID: Atomicity    | No partial update; DB is never left inconsistent |
| ðŸ“¦ Tech Stack         | PostgreSQL + Prisma + Docker + Express           |


Contents of 1_atomicity/AppExample/docker-compose.yml:

version: "3.8"

services:
  db:
    image: postgres:15
    container_name: pg_transfer_example_container
    restart: always
    environment:
      POSTGRES_DB: bankdb
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: secret
    ports:
      - "5432:5432"
    volumes:
      - ./init-db:/docker-entrypoint-initdb.d


Contents of 1_atomicity/AppExample/init-db/init.sql:

-- Create a single 'account' table
CREATE TABLE IF NOT EXISTS account (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  balance NUMERIC(12, 2) NOT NULL CHECK (balance >= 0)
);

-- Seed data: Alice and Bob
INSERT INTO account (name, balance)
VALUES
  ('Alice', 1000.00),
  ('Bob', 500.00)
ON CONFLICT (name) DO NOTHING;


Contents of 1_atomicity/AppExample/server/package.json:

{
  "type": "module",
  "dependencies": {
    "@prisma/client": "^6.7.0",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "nodemon": "^3.1.10"
  },
  "devDependencies": {
    "prisma": "^6.7.0"
  }
}


Contents of 1_atomicity/AppExample/server/.env:

DATABASE_URL="postgresql://admin:secret@localhost:5432/bankdb"


Contents of 1_atomicity/AppExample/server/app.js:

import cors from "cors";
import express from "express";
import accountRoutes from "./routes/accounts.js";

const app = express();
app.use(cors());
app.use(express.json());

app.use("/api/accounts", accountRoutes);

const PORT = 3001;
app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
});


Contents of 1_atomicity/AppExample/server/prisma/schema.prisma:

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model Account {
    id      Int    @id @default(autoincrement())
    name    String @unique
    balance Float  @default(0)

    @@map("account")
}


Contents of 1_atomicity/AppExample/server/routes/accounts.js:

import { PrismaClient } from "@prisma/client";
import express from "express";

const prisma = new PrismaClient();
const router = express.Router();

// âœ… Uppercase "A" matches model name in schema.prisma
router.get("/", async (_, res) => {
  const accounts = await prisma.Account.findMany();
  res.json(accounts);
});

router.post("/transfer", async (req, res) => {
  const { from, to, amount } = req.body;

  try {
    await prisma.$transaction([
      prisma.Account.update({
        where: { name: from },
        data: { balance: { decrement: amount } },
      }),
      prisma.Account.update({
        where: { name: to },
        data: { balance: { increment: amount } },
      }),
    ]);

    res.json({ success: true });
  } catch (err) {
    res.status(400).json({ success: false, message: err.message });
  }
});

export default router;


